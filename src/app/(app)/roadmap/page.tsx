
"use client";

import React, { useState, useEffect, useCallback, useMemo } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ArrowUp, BookOpen, Users2, Palette, DollarSign, BarChart3, RefreshCw, MessageSquarePlus, GitFork, Gauge, Sparkles, Lightbulb, UserPlus, LogIn, Loader2, ChevronUp, Info as InfoIcon, UserCheck, Layers, HelpCircle, Tag } from "lucide-react";
import { useAuth } from "@/contexts/AuthContext";
import Link from "next/link";
import { useRouter, useSearchParams } from 'next/navigation'; // Import useRouter and useSearchParams
import { cn } from "@/lib/utils";
import { useAppContext } from "../layout";
import { Badge } from "@/components/ui/badge";
import { db } from '@/lib/firebase';
import { collection, getDocs, doc, updateDoc, increment, writeBatch, serverTimestamp, query, where, getDoc, setDoc } from 'firebase/firestore';
import { useToast } from "@/hooks/use-toast";

// Define a type for the Lucide icon names we'll use
type LucideIconName = keyof typeof LucideIconsMap;

interface RoadmapFeature {
  id: string; // Firestore document ID
  featureId: string; // A unique, stable string ID for the feature
  iconName: LucideIconName;
  title: string;
  tagline: string; // Short tagline for Product Hunt style
  description: string; // Longer description for context
  status: "Planned" | "In Progress" | "Researching" | "Future (Post Early Access)" | "Suggested";
  currentVotes: number;
  category: "Client Acquisition" | "Client Management" | "Agent Capabilities" | "Platform Growth" | "Advanced Features";
  tags?: string[]; // Optional: for filtering/display
}

// Helper map to get Lucide components by name
const LucideIconsMap = {
  BookOpen, Users2, Palette, DollarSign, BarChart3, RefreshCw, MessageSquarePlus, GitFork, Gauge, Sparkles, Lightbulb, InfoIcon, UserCheck, Layers, HelpCircle, Tag
};

// Static list of features to ensure some are always visible, especially for MVP
const staticFeaturesList: Omit<RoadmapFeature, 'id' | 'currentVotes'>[] = [
  { featureId: "sales_playbook", iconName: "BookOpen", title: "Sales Playbook & Client Kit", tagline: "Guides & templates to land clients.", description: "Step-by-step guides, proposal templates, and checklists to help you confidently find and sign your first AI agency clients. Helps you get started selling effectively.", status: "Planned", category: "Client Acquisition", tags: ["sales", "onboarding", "templates"] },
  { featureId: "client_crm_basic", iconName: "Users2", title: "Simple Client Lead CRM", tagline: "Track leads AI agents generate.", description: "A lightweight tool integrated with agents to help your clients track and manage leads or inquiries generated by their AI. Basic but effective.", status: "Researching", category: "Client Management", tags: ["crm", "leads", "client tools"] },
  { featureId: "agent_analytics_basic", iconName: "BarChart3", title: "Basic Agent Analytics", tagline: "Show clients agent performance.", description: "Provide your clients with simple dashboards showing agent usage (e.g., number of conversations, common questions). Value demonstration for your clients.", status: "Planned", category: "Client Management", tags: ["analytics", "reporting", "client value"] },
  { featureId: "knowledge_sync_auto", iconName: "RefreshCw", title: "Auto Knowledge Sync (URL)", tagline: "Keep agent knowledge fresh from sites.", description: "Allow agents to periodically re-fetch content from a specified client website URL to keep knowledge up-to-date automatically. Reduces manual updates.", status: "Researching", category: "Agent Capabilities", tags: ["automation", "knowledge", "website sync"] },
  { featureId: "ai_content_assist", iconName: "Sparkles", title: "AI Content Generation Aid", tagline: "Draft agent content faster.", description: "Tools to help quickly draft agent responses, example FAQs, or knowledge base summaries for your clients. Speeds up your workflow.", status: "Planned", category: "Agent Capabilities", tags: ["ai writing", "efficiency", "content"] },
  { featureId: "whitelabel_platform", iconName: "Palette", title: "Whitelabel Platform", tagline: "Your brand on AutoBoss (Future).", description: "Offer AutoBoss agents and parts of the platform under your agency's branding. (Planned for a future paid offering).", status: "Future (Post Early Access)", category: "Platform Growth", tags: ["branding", "whitelabel", "pro feature"] },
  { featureId: "affiliate_program", iconName: "DollarSign", title: "AutoBoss Affiliate Program", tagline: "Earn by referring (Future).", description: "Partner with us. Earn by recommending AutoBoss once we introduce subscription plans after the early adopter phase.", status: "Future (Post Early Access)", category: "Platform Growth", tags: ["affiliate", "partnership", "monetization"] },
];


export default function RoadmapPage() {
  const { currentUser } = useAuth();
  const { theme } = useAppContext();
  const [features, setFeatures] = useState<RoadmapFeature[]>([]);
  const [isLoadingFeatures, setIsLoadingFeatures] = useState(true);
  const [votedFeatures, setVotedFeatures] = useState<Record<string, boolean>>({}); 
  const [isVoting, setIsVoting] = useState<Record<string, boolean>>({}); 
  const [showAuthPrompt, setShowAuthPrompt] = useState(false);
  const { toast } = useToast();
  const router = useRouter();
  const searchParamsHook = useSearchParams(); // For redirect after login

  const fetchFeaturesAndUserVotes = useCallback(async () => {
    setIsLoadingFeatures(true);
    try {
      const featuresCollection = collection(db, "roadmapFeatures");
      const featuresSnapshot = await getDocs(featuresCollection);
      let fetchedFeaturesMap: Map<string, RoadmapFeature> = new Map();

      featuresSnapshot.docs.forEach(doc => {
        const data = doc.data();
        // Ensure currentVotes is a number, default to 0 if not present
        const currentVotes = typeof data.currentVotes === 'number' ? data.currentVotes : 0;
        const feature = { id: doc.id, ...data, currentVotes } as RoadmapFeature;
        if (feature.featureId) { // Only add if featureId exists
           fetchedFeaturesMap.set(feature.featureId, feature);
        }
      });

      // Merge static list with fetched data, prioritizing fetched data for votes
      // but ensuring all static features are present
      const mergedFeatures = staticFeaturesList.map(staticFeature => {
        const firestoreFeature = fetchedFeaturesMap.get(staticFeature.featureId);
        if (firestoreFeature) {
          return { 
            ...staticFeature, // base from static
            ...firestoreFeature, // override with firestore data like id and currentVotes
            currentVotes: firestoreFeature.currentVotes || 0 // ensure votes is number
          };
        }
        return { ...staticFeature, id: staticFeature.featureId, currentVotes: 0 }; // Fallback if not in Firestore
      });
      
      setFeatures(
        mergedFeatures.sort((a, b) => {
          if (b.currentVotes !== a.currentVotes) return b.currentVotes - a.currentVotes;
          return a.title.localeCompare(b.title);
        })
      );

      if (currentUser) {
        const userVotesQuery = query(collection(db, "userVotes"), where("userId", "==", currentUser.uid));
        const userVotesSnapshot = await getDocs(userVotesQuery);
        const userVotesData: Record<string, boolean> = {};
        userVotesSnapshot.forEach(doc => {
          userVotesData[doc.data().featureId as string] = true;
        });
        setVotedFeatures(userVotesData);
        localStorage.setItem(`votedFeatures_${currentUser.uid}`, JSON.stringify(userVotesData));
      } else {
        // For logged-out users, load votes from localStorage if any (visual only)
        const localVotes = localStorage.getItem('anonymousVotedFeatures');
        if (localVotes) {
          setVotedFeatures(JSON.parse(localVotes));
        } else {
          setVotedFeatures({});
        }
      }

    } catch (error) {
      console.error("Error fetching roadmap data:", error);
      toast({ title: "Error", description: "Could not load roadmap features. Showing defaults.", variant: "destructive" });
      // Fallback to static list if Firestore fails
      setFeatures(staticFeaturesList.map(f => ({...f, id: f.featureId, currentVotes: 0 })).sort((a,b) => a.title.localeCompare(b.title)));
    } finally {
      setIsLoadingFeatures(false);
    }
  }, [currentUser, toast]);

  useEffect(() => {
    fetchFeaturesAndUserVotes();
  }, [fetchFeaturesAndUserVotes]);
  

  const handleVote = async (featureDocIdOrFeatureId: string, featureStableId: string) => {
    setIsVoting(prev => ({ ...prev, [featureDocIdOrFeatureId]: true }));

    if (currentUser) { // Logged-in user: Persist vote
      if (votedFeatures[featureStableId]) {
        toast({ title: "Already Voted", description: "You've already upvoted this feature.", variant: "default" });
        setIsVoting(prev => ({ ...prev, [featureDocIdOrFeatureId]: false }));
        return;
      }

      const originalFeatures = [...features];
      const originalVotedFeatures = {...votedFeatures};

      setFeatures(prevFeatures => 
          prevFeatures.map(f => f.featureId === featureStableId ? {...f, currentVotes: (f.currentVotes || 0) + 1} : f)
          .sort((a, b) => b.currentVotes - a.currentVotes)
      );
      const newVotedFeatures = { ...votedFeatures, [featureStableId]: true };
      setVotedFeatures(newVotedFeatures);
      localStorage.setItem(`votedFeatures_${currentUser.uid}`, JSON.stringify(newVotedFeatures));

      try {
        const featureRef = doc(db, "roadmapFeatures", featureDocIdOrFeatureId); // Use docId if available (from Firestore)
        // Check if feature exists in Firestore before trying to update
        const featureSnap = await getDoc(featureRef);

        const userVoteRef = doc(db, "userVotes", `${currentUser.uid}_${featureStableId}`);
        const batch = writeBatch(db);

        if (featureSnap.exists()) {
            batch.update(featureRef, { currentVotes: increment(1) });
        } else {
            // Feature might not be in Firestore yet (if relying on static list primarily)
            // Create it or handle this case appropriately. For MVP, we might assume it exists if we are trying to vote.
            // Or, only allow voting on features confirmed to be in Firestore.
            // For now, let's assume if it has a Firestore ID, it's there.
            // If featureDocIdOrFeatureId *is* featureStableId because it's from static list, this won't work well.
            // This needs robust handling of whether the feature exists in DB.
            // Simplification: Assume `featureDocIdOrFeatureId` is the actual Firestore document ID.
             console.warn(`Feature with ID ${featureDocIdOrFeatureId} not found in Firestore to update votes. Vote recorded locally for user.`);
             // To make it persist, we would need to create the document in roadmapFeatures first
             // For now, local optimistic update + userVote record is fine.
        }
        
        batch.set(userVoteRef, { 
          userId: currentUser.uid, 
          featureId: featureStableId, 
          votedAt: serverTimestamp() 
        });
        await batch.commit();
        
        toast({ title: "Vote Cast!", description: "Thanks for your feedback!" });
      } catch (error) {
        console.error("Error casting vote:", error);
        toast({ title: "Voting Error", description: "Could not save your vote. Please try again.", variant: "destructive" });
        setFeatures(originalFeatures); // Revert optimistic update
        setVotedFeatures(originalVotedFeatures);
        localStorage.setItem(`votedFeatures_${currentUser.uid}`, JSON.stringify(originalVotedFeatures));
      }
    } else { // Logged-out user: Visual vote + localStorage
      const currentAnonymousVotes = JSON.parse(localStorage.getItem('anonymousVotedFeatures') || '{}');
      if (currentAnonymousVotes[featureStableId]) {
        toast({ title: "Already Voted (This Session)", description: "Your vote is noted for this session.", variant: "default" });
        setIsVoting(prev => ({ ...prev, [featureDocIdOrFeatureId]: false }));
        return;
      }
      
      setFeatures(prevFeatures => 
          prevFeatures.map(f => f.featureId === featureStableId ? {...f, currentVotes: (f.currentVotes || 0) + 1} : f)
          .sort((a, b) => b.currentVotes - a.currentVotes)
      );
      const newAnonymousVotes = { ...currentAnonymousVotes, [featureStableId]: true };
      setVotedFeatures(newAnonymousVotes); // Update component state to reflect visual vote
      localStorage.setItem('anonymousVotedFeatures', JSON.stringify(newAnonymousVotes));
      toast({ title: "Vote Noted!", description: "Log in or sign up to make your vote permanent and help us prioritize!", duration: 5000 });
    }
    setIsVoting(prev => ({ ...prev, [featureDocIdOrFeatureId]: false }));
  };
  
  const handleSuggestFeature = () => {
     if (!currentUser) {
      setShowAuthPrompt(true); // This will show the login/signup prompt
      return;
    }
    // For now, placeholder for actual suggestion submission
    toast({title: "Coming Soon!", description: "Feature suggestion submission is planned. We're excited to hear your ideas!", duration: 5000});
  };
  
  const sortedFeatures = useMemo(() => {
    return [...features].sort((a, b) => {
        const votesA = a.currentVotes || 0;
        const votesB = b.currentVotes || 0;
        if (votesB !== votesA) {
          return votesB - votesA;
        }
        return a.title.localeCompare(b.title);
      });
  }, [features]);

  return (
    <div className="container mx-auto py-6 sm:py-8 px-2 sm:px-4 md:px-6 max-w-screen-lg">
      <Card className="mb-6 sm:mb-8 bg-card/70 dark:bg-card/60 backdrop-blur-sm">
        <CardHeader className="p-4 sm:p-6">
          <CardTitle className={cn("font-headline text-xl sm:text-2xl flex items-center gap-2", "text-gradient-dynamic")}>
            <Lightbulb className="w-6 h-6 sm:w-7 sm:w-7 text-primary" />
            AutoBoss Roadmap: Help Shape Our Future
          </CardTitle>
          <CardDescription className="text-sm">
            We're building AutoBoss with our community. Your input on these potential features helps us prioritize what to build next.
            Upvote your favorites! Have an idea? We'd love to hear it.
          </CardDescription>
        </CardHeader>
      </Card>

      {showAuthPrompt && (
        <Alert className="mb-4 sm:mb-6 border-primary/50 bg-primary/5">
          <UserPlus className="h-4 w-4 text-primary" />
          <AlertTitle className="text-primary">Want to participate fully?</AlertTitle>
          <AlertDescription className="text-sm">
            Please&nbsp;
            <Link href={`/login?redirect=/roadmap`} className="font-semibold underline hover:text-accent">Log In</Link> 
            &nbsp;or&nbsp; 
            <Link href={`/signup?redirect=/roadmap`} className="font-semibold underline hover:text-accent">Sign Up</Link> 
            &nbsp;to permanently save your votes or suggest new ideas.
            <Button variant="ghost" size="sm" onClick={() => setShowAuthPrompt(false)} className="ml-2 text-xs h-auto p-1 text-primary">Dismiss</Button>
          </AlertDescription>
        </Alert>
      )}
      
      {isLoadingFeatures ? (
        <div className="flex justify-center items-center py-10">
          <Loader2 className="h-10 w-10 animate-spin text-primary"/>
        </div>
      ) : sortedFeatures.length === 0 && !isLoadingFeatures ? (
         <Alert>
            <Lightbulb className="h-4 w-4" />
            <AlertTitle>Roadmap is Evolving!</AlertTitle>
            <AlertDescription>
              We're currently gathering initial feedback. Features will appear here soon. Check back or suggest an idea!
            </AlertDescription>
          </Alert>
      ) : (
        <div className="space-y-3 sm:space-y-4">
            {sortedFeatures.map((feature) => {
              const IconComponent = LucideIconsMap[feature.iconName] || Lightbulb;
              // feature.id here might be the Firestore doc ID or the featureStableId if from static list
              const docIdToUseForVote = feature.id; 
              const hasVoted = !!votedFeatures[feature.featureId];
              const votingInProgress = !!isVoting[docIdToUseForVote];
              return (
                <div key={feature.featureId} className="roadmap-item-card">
                  <Button
                    variant="outline"
                    onClick={() => handleVote(docIdToUseForVote, feature.featureId)}
                    disabled={votingInProgress || (hasVoted && !!currentUser)} // Allow re-clicking for anonymous for visual feedback
                    className={cn("roadmap-vote-button-ph", hasVoted && !!currentUser && "voted")}
                    aria-label={`Upvote ${feature.title}`}
                  >
                    {votingInProgress ? <Loader2 className="h-4 w-4 animate-spin" /> : <ChevronUp />}
                    <span className="vote-count-ph">{feature.currentVotes || 0}</span>
                  </Button>
                  <div className="roadmap-feature-main">
                    <div className="roadmap-feature-header">
                        <div className="roadmap-feature-icon-ph"><IconComponent /></div>
                        <h3 className="roadmap-feature-title-ph">{feature.title}</h3>
                    </div>
                    <p className="roadmap-feature-description-ph">{feature.tagline}</p>
                     <div className="roadmap-feature-tags-ph">
                      <Badge variant="outline" className="text-[10px] h-fit px-1.5 py-0.5">{feature.category}</Badge>
                      <Badge 
                        variant={feature.status === "Planned" ? "default" : feature.status === "In Progress" ? "secondary" : "outline"} 
                        className={cn("text-[10px] h-fit px-1.5 py-0.5", 
                          {"bg-green-500/20 text-green-700 border-green-500/40 dark:text-green-400": feature.status === "In Progress"},
                          {"bg-blue-500/20 text-blue-700 border-blue-500/40 dark:text-blue-400": feature.status === "Planned"},
                          {"bg-purple-500/10 text-purple-700 border-purple-500/30 dark:text-purple-400": feature.status === "Suggested"}
                        )}
                      >
                        {feature.status}
                      </Badge>
                       {feature.tags?.map(tag => (
                        <Badge key={tag} variant="secondary" className="text-[10px] h-fit px-1.5 py-0.5 font-normal bg-muted/50 border-border/50"><Tag className="w-2.5 h-2.5 mr-0.5"/>{tag}</Badge>
                      ))}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
      )}
      
      <div className="mt-8 sm:mt-12 text-center">
        <Card className="inline-block p-4 sm:p-6 bg-card/80 dark:bg-card/70 backdrop-blur-sm">
            <CardTitle className="text-lg sm:text-xl mb-2 font-headline">Have a Brilliant Idea?</CardTitle>
            <CardDescription className="text-sm mb-3 text-muted-foreground max-w-md mx-auto">
                If there's something else you'd love to see in AutoBoss that would make your AI agency journey even better, let us know!
            </CardDescription>
            <Button onClick={handleSuggestFeature} className={cn("btn-gradient-primary")}>
                <Lightbulb className="mr-2 h-4 w-4"/>
                Suggest a New Feature
            </Button>
        </Card>
      </div>
       <Alert variant="default" className="mt-8 text-xs text-muted-foreground bg-muted/50">
        <InfoIcon className="h-4 w-4" />
        <AlertTitle>Feature Voting & Suggestions</AlertTitle>
        <AlertDescription>
          Upvoting helps us gauge community interest. To suggest a new feature or ensure your vote is permanently recorded, please sign in or create an account. Anonymous votes are for local session feedback only.
        </AlertDescription>
      </Alert>
    </div>
  );
}
    

    