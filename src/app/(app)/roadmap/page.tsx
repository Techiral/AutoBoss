
"use client";

import { useState, useEffect, useCallback, useMemo } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ArrowUp, BookOpen, Users2, Palette, DollarSign, BarChart3, RefreshCw, MessageSquarePlus, GitFork, Gauge, Sparkles, Lightbulb, UserPlus, LogIn, Loader2, ChevronUp } from "lucide-react";
import { useAuth } from "@/contexts/AuthContext";
import Link from "next/link";
import { cn } from "@/lib/utils";
import { useAppContext } from "../layout";
import { Badge } from "@/components/ui/badge";
import { db } from '@/lib/firebase';
import { collection, getDocs, doc, updateDoc, increment } from 'firebase/firestore';
import { useToast } from "@/hooks/use-toast";

// Define a type for the Lucide icon names we'll use
type LucideIconName = keyof typeof LucideIconsMap;

interface RoadmapFeature {
  id: string; // Firestore document ID
  featureId: string; // A unique, stable string ID for the feature
  iconName: LucideIconName; 
  title: string;
  description: string;
  status: "Planned" | "In Progress" | "Researching" | "Future (Post Early Access)" | "Suggested";
  currentVotes: number;
  category: "Client Acquisition" | "Client Management" | "Agent Capabilities" | "Platform Growth" | "Advanced Features";
}

// Helper map to get Lucide components by name
const LucideIconsMap = {
  BookOpen, Users2, Palette, DollarSign, BarChart3, RefreshCw, MessageSquarePlus, GitFork, Gauge, Sparkles, Lightbulb
};


// Initial features to seed if Firestore is empty (admin task, not done by this code)
// Ensure iconName matches a key in LucideIconsMap
const initialFeaturesSeedForAdmin: Omit<RoadmapFeature, 'id' | 'currentVotes'>[] = [
  // ... (keep your seed data here for reference, but this code won't auto-seed)
  { featureId: "sales_playbook", iconName: "BookOpen", title: "Sales Playbook & Client Acquisition Kit", description: "Step-by-step guides, proposal templates, and checklists to help you confidently find and sign your first AI agency clients.", status: "Planned", category: "Client Acquisition" },
  { featureId: "client_crm_basic", iconName: "Users2", title: "Simple Client Lead Management", description: "A lightweight tool integrated with agents to help your clients track and manage leads or inquiries generated by their AI.", status: "Researching", category: "Client Management" },
  { featureId: "agent_analytics_basic", iconName: "BarChart3", title: "Basic Agent Analytics for Clients", description: "Provide your clients with simple dashboards showing agent usage (e.g., number of conversations, common questions).", status: "Planned", category: "Client Management" },
  { featureId: "knowledge_sync_auto", iconName: "RefreshCw", title: "Automated Knowledge Sync (Basic)", description: "Allow agents to periodically re-fetch content from a specified client website URL to keep knowledge up-to-date.", status: "Researching", category: "Agent Capabilities" },
  { featureId: "ai_content_assist", iconName: "Sparkles", title: "AI-Assisted Content Generation", description: "Tools to help quickly draft agent responses, example FAQs, or knowledge base summaries for your clients.", status: "Planned", category: "Agent Capabilities" },
  { featureId: "whitelabel_platform", iconName: "Palette", title: "Whitelabel Platform (Future Pro Tier)", description: "Offer AutoBoss agents and parts of the platform under your agency's branding. (Planned for a future paid offering).", status: "Future (Post Early Access)", category: "Platform Growth" },
  { featureId: "affiliate_program", iconName: "DollarSign", title: "AutoBoss Affiliate Program", description: "Partner with us. Earn by recommending AutoBoss once we introduce subscription plans after the early adopter phase.", status: "Future (Post Early Access)", category: "Platform Growth" },
];

export default function RoadmapPage() {
  const { currentUser } = useAuth();
  const { theme } = useAppContext();
  const [features, setFeatures] = useState<RoadmapFeature[]>([]);
  const [isLoadingFeatures, setIsLoadingFeatures] = useState(true);
  const [votedFeatures, setVotedFeatures] = useState<Record<string, boolean>>({});
  const [showAuthPrompt, setShowAuthPrompt] = useState(false);
  const { toast } = useToast();

  const fetchFeatures = useCallback(async () => {
    setIsLoadingFeatures(true);
    try {
      const featuresCollection = collection(db, "roadmapFeatures");
      const snapshot = await getDocs(featuresCollection);
      if (snapshot.empty) {
        // This is where an admin might run a seeding script.
        // For now, users will see an empty list if not seeded.
        console.warn("Roadmap features collection is empty in Firestore. Please seed it with initial features.");
        setFeatures([]);
      } else {
        const fetchedFeatures = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as RoadmapFeature));
        // Sort by votes descending, then by title alphabetically for tie-breaking
        setFeatures(
          fetchedFeatures.sort((a, b) => {
            if (b.currentVotes !== a.currentVotes) {
              return b.currentVotes - a.currentVotes;
            }
            return a.title.localeCompare(b.title);
          })
        );
      }
    } catch (error) {
      console.error("Error fetching roadmap features:", error);
      toast({ title: "Error", description: "Could not load roadmap features. Please ensure the 'roadmapFeatures' collection exists in Firestore.", variant: "destructive" });
    } finally {
      setIsLoadingFeatures(false);
    }
  }, [toast]);

  useEffect(() => {
    fetchFeatures();
  }, [fetchFeatures]);
  
  // Load voted features from localStorage for persistence for the current user
  useEffect(() => {
    if (currentUser) {
      const storedVotes = localStorage.getItem(`votedFeatures_${currentUser.uid}`);
      if (storedVotes) {
        setVotedFeatures(JSON.parse(storedVotes));
      }
    } else {
      setVotedFeatures({}); // Clear if user logs out
    }
  }, [currentUser]);

  const handleVote = async (featureDocId: string, featureId: string) => {
    if (!currentUser) {
      setShowAuthPrompt(true);
      return;
    }
    if (votedFeatures[featureId]) { // Check against stable featureId
      toast({ title: "Already Voted", description: "You've already upvoted this feature.", variant: "default" });
      return;
    }

    const newVotedFeatures = { ...votedFeatures, [featureId]: true };
    setVotedFeatures(newVotedFeatures);
    localStorage.setItem(`votedFeatures_${currentUser.uid}`, JSON.stringify(newVotedFeatures));
    
    setFeatures(prevFeatures => 
        prevFeatures.map(f => f.id === featureDocId ? {...f, currentVotes: f.currentVotes + 1} : f)
        .sort((a, b) => b.currentVotes - a.currentVotes)
    );

    try {
      const featureRef = doc(db, "roadmapFeatures", featureDocId);
      // IMPORTANT: Direct client-side increments are not secure for critical vote counting in production.
      // A Firebase Function triggered by a write to a separate "votes" collection is recommended
      // to validate users and prevent multiple votes. This is a simplified approach for now.
      await updateDoc(featureRef, {
        currentVotes: increment(1)
      });
      toast({ title: "Vote Cast!", description: "Thanks for your feedback!" });
    } catch (error) {
      console.error("Error casting vote:", error);
      toast({ title: "Voting Error", description: "Could not save your vote. Please try again.", variant: "destructive" });
      // Revert optimistic update on error
      const revertedVotedFeatures = { ...votedFeatures };
      delete revertedVotedFeatures[featureId];
      setVotedFeatures(revertedVotedFeatures);
      localStorage.setItem(`votedFeatures_${currentUser.uid}`, JSON.stringify(revertedVotedFeatures));

      setFeatures(prevFeatures => 
          prevFeatures.map(f => f.id === featureDocId ? {...f, currentVotes: f.currentVotes - 1} : f)
          .sort((a, b) => b.currentVotes - a.currentVotes)
      );
    }
  };
  
  const handleSuggestFeature = () => {
     if (!currentUser) {
      setShowAuthPrompt(true);
      return;
    }
    toast({title: "Coming Soon!", description: "Feature suggestion submission is planned for a future update. We're excited to hear your ideas!"});
  };

  return (
    <div className="container mx-auto py-6 sm:py-8 px-4 md:px-6 max-w-screen-lg">
      <Card className="mb-6 sm:mb-8 bg-card/70 dark:bg-card/60 backdrop-blur-sm">
        <CardHeader className="p-4 sm:p-6">
          <CardTitle className={cn("font-headline text-xl sm:text-2xl flex items-center gap-2", "text-gradient-dynamic")}>
            <Lightbulb className="w-6 h-6 sm:w-7 sm:w-7 text-primary" />
            AutoBoss Roadmap: Help Shape Our Future
          </CardTitle>
          <CardDescription className="text-sm">
            We're building AutoBoss with our community. Your input on these potential features helps us prioritize what to build next.
            Upvote your favorites, or suggest new ideas!
          </CardDescription>
        </CardHeader>
      </Card>

      {showAuthPrompt && (
        <Alert className="mb-4 sm:mb-6 border-primary/50 bg-primary/5">
          <UserPlus className="h-4 w-4 text-primary" />
          <AlertTitle className="text-primary">Want to participate?</AlertTitle>
          <AlertDescription className="text-sm">
            Please <Link href="/login" className="font-semibold underline hover:text-accent">Log In</Link> or <Link href="/signup" className="font-semibold underline hover:text-accent">Sign Up</Link> to upvote features or suggest new ideas.
            <Button variant="ghost" size="sm" onClick={() => setShowAuthPrompt(false)} className="ml-2 text-xs h-auto p-1 text-primary">Dismiss</Button>
          </AlertDescription>
        </Alert>
      )}
      
      {isLoadingFeatures ? (
        <div className="flex justify-center items-center py-10">
          <Loader2 className="h-10 w-10 animate-spin text-primary"/>
        </div>
      ) : features.length === 0 && !isLoadingFeatures ? (
         <Alert>
            <Lightbulb className="h-4 w-4" />
            <AlertTitle>Roadmap is Evolving!</AlertTitle>
            <AlertDescription>
              We're currently gathering initial feedback. Features will appear here soon. Check back or suggest an idea!
              <br/><span className="text-xs text-muted-foreground">(Admin: Ensure 'roadmapFeatures' collection in Firestore is populated with initial feature data.)</span>
            </AlertDescription>
          </Alert>
      ) : (
        <div className="bg-card border rounded-lg shadow-sm">
          <ul className="divide-y divide-border/50">
            {features.map((feature) => {
              const IconComponent = LucideIconsMap[feature.iconName] || Lightbulb; // Default to Lightbulb if iconName is invalid
              const hasVoted = votedFeatures[feature.featureId];
              return (
                <li key={feature.id} className="roadmap-list-item group">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handleVote(feature.id, feature.featureId)}
                    disabled={hasVoted || (!currentUser && showAuthPrompt)}
                    className={cn("roadmap-vote-button", hasVoted && "voted")}
                    aria-label={`Upvote ${feature.title}`}
                  >
                    <ChevronUp />
                    <span>{feature.currentVotes || 0}</span>
                  </Button>
                  <div className="roadmap-feature-content">
                    <h3 className="roadmap-feature-title">
                      <IconComponent />
                      {feature.title}
                    </h3>
                    <p className="roadmap-feature-description">{feature.description}</p>
                    <div className="roadmap-feature-tags">
                      <Badge variant="outline" className="text-[10px] h-fit px-1.5 py-0.5">{feature.category}</Badge>
                      <Badge 
                        variant={feature.status === "Planned" ? "default" : feature.status === "In Progress" ? "secondary" : "outline"} 
                        className={cn("text-[10px] h-fit px-1.5 py-0.5", 
                          {"bg-green-500/20 text-green-700 border-green-500/40 dark:text-green-400": feature.status === "In Progress"},
                          {"bg-blue-500/20 text-blue-700 border-blue-500/40 dark:text-blue-400": feature.status === "Planned"},
                          {"bg-purple-500/10 text-purple-700 border-purple-500/30 dark:text-purple-400": feature.status === "Suggested"}
                        )}
                      >
                        {feature.status}
                      </Badge>
                    </div>
                  </div>
                </li>
              );
            })}
          </ul>
        </div>
      )}
      
      <div className="mt-8 sm:mt-12 text-center">
        <Card className="inline-block p-4 sm:p-6 bg-card/80 dark:bg-card/70 backdrop-blur-sm">
            <CardTitle className="text-lg sm:text-xl mb-2 font-headline">Have a Brilliant Idea?</CardTitle>
            <CardDescription className="text-sm mb-3 text-muted-foreground max-w-md mx-auto">
                If there's something else you'd love to see in AutoBoss that would make your AI agency journey even better, let us know!
            </CardDescription>
            <Button onClick={handleSuggestFeature} className={cn("btn-gradient-primary")}>
                <Lightbulb className="mr-2 h-4 w-4"/>
                Suggest a New Feature
            </Button>
        </Card>
      </div>
      <Alert variant="default" className="mt-8 text-xs text-muted-foreground bg-muted/50">
        <Info className="h-4 w-4" />
        <AlertTitle>For Admins/Developers</AlertTitle>
        <AlertDescription>
          To populate the roadmap, ensure you have a 'roadmapFeatures' collection in Firestore. Each document should include fields like `featureId` (string, e.g., "sales_playbook"), `title` (string), `description` (string), `iconName` (string, e.g., "BookOpen" - must match a key in LucideIconsMap in the component), `category` (string), `status` (string), and `currentVotes` (number, typically initialized to 0). Secure voting (preventing multiple votes per user) ideally requires a Firebase Cloud Function.
        </AlertDescription>
      </Alert>
    </div>
  );
}
