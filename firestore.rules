
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection:
    // Users can read and write their own user profile document.
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Clients collection:
    // Rules for individual documents
    match /clients/{clientId} {
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      // Owners can get, update, or delete their own client documents.
      allow get, update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    // Rules for querying the clients collection
    match /clients {
      // Allow listing clients if the query is made by an authenticated user
      // AND the query filters by that user's specific userId.
      allow list: if request.auth != null &&
                     request.query.filters.find(f => f[0] == "userId" && f[1] == "==" && f[2] == request.auth.uid) != null;
    }

    // Agents collection:
    // Rules for individual documents
    match /agents/{agentId} {
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      // An agent document can be read if:
      // 1. The requester is the authenticated owner.
      // OR
      // 2. The agent is marked as publicly shared.
      allow get: if (request.auth != null && resource.data.userId == request.auth.uid) ||
                     (resource.data.isPubliclyShared == true);
      // Owners can update or delete their own agents.
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    // Rules for querying the agents collection
    match /agents {
      // Allow listing agents if:
      // 1. An authenticated user is querying for their own agents (query must filter by userId).
      // OR
      // 2. Anyone (authenticated or not) is querying for publicly shared agents (query must filter by isPubliclyShared == true).
      allow list: if (request.auth != null && request.query.filters.find(f => f[0] == "userId" && f[1] == "==" && f[2] == request.auth.uid) != null) ||
                     (request.query.filters.find(f => f[0] == "isPubliclyShared" && f[1] == "==" && f[2] == true) != null);
    }

    // OutboundQueue collection:
    // Authenticated users can create new tasks in the queue.
    match /outboundQueue/{taskId} {
      allow create: if request.auth != null;
      // Example: allow read, update, delete: if <your_condition_for_admin_or_backend_worker>;
    }

    // Roadmap Features: Anyone can read.
    // Authenticated users can update votes by exactly +1, only affecting the currentVotes field.
    match /roadmapFeatures/{featureDocId} {
      allow read: if true;
      allow update: if request.auth != null &&
                       request.resource.data.currentVotes == resource.data.currentVotes + 1 &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['currentVotes']);
    }

    // User Votes:
    // Documents are named like "{userId}_{featureId}".
    // Users can read their own vote documents.
    // Users can create their own vote document if specific conditions are met.
    match /userVotes/{voteId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow create: if request.auth != null &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.featureId != null &&
                       voteId == request.resource.data.userId + '_' + request.resource.data.featureId;
    }
  }
}

    