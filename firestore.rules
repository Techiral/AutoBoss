
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection:
    // Users can read and write their own user profile document.
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Clients collection:
    // Authenticated users can create clients for themselves.
    // Users can read, update, or delete clients they own.
    match /clients/{clientId} {
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow read, update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // Agents collection - Document Level Rules
    match /agents/{agentId} {
      // Create, Update, Delete only by the authenticated owner
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;

      // GET rule:
      // - Authenticated owner can get their own agent (whether public or private).
      // - Anyone can get an agent IF it is publicly shared.
      // This rule is checked for every document read, including those returned by a list operation.
      allow get: if (request.auth != null && resource.data.userId == request.auth.uid) ||
                       (resource.data.isPubliclyShared == true);
    }

    // Agents collection - Collection Level Rules (for list operations)
    match /agents {
      // Authenticated users can list agents.
      // For users to see only "their" agents, the client-side query MUST include
      // `where('userId', '==', request.auth.uid)`.
      // The per-document 'get' rule above will then ensure they can read their own.
      // If they query more broadly, the 'get' rule still filters what they can actually see.
      allow list: if request.auth != null;

      // Unauthenticated users (e.g., the public showcase page) can list agents.
      // The client-side query for the showcase page MUST filter by `where('isPubliclyShared', '==', true)`.
      // The per-document 'get' rule for `agents/{agentId}` (specifically `resource.data.isPubliclyShared == true`)
      // will then ensure that only these publicly shared documents are actually returned from the list operation.
      allow list: if request.auth == null;

      // Note: Firestore rules OR conditions within the same 'allow' statement.
      // The two 'allow list' rules above effectively mean `allow list: if true;` (anyone can attempt to list),
      // but separating them can make intent clearer. The crucial part is that the per-document 'get' rule
      // correctly filters the results of any list operation.
    }

    // OutboundQueue collection:
    // Authenticated users can create new tasks in the queue.
    match /outboundQueue/{taskId} {
      allow create: if request.auth != null;
      // allow read, update, delete: if <your_condition_for_admin_or_backend_worker>; // Example
    }

    // Roadmap Features: Anyone can read.
    // Authenticated users can update votes by exactly +1, only affecting the currentVotes field.
    match /roadmapFeatures/{featureDocId} {
      allow read: if true;
      allow update: if request.auth != null &&
                       request.resource.data.currentVotes == resource.data.currentVotes + 1 &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['currentVotes']);
    }

    // User Votes:
    // - Documents are named like "{userId}_{featureId}".
    // - Users can read their own vote documents (by checking resource.data.userId).
    // - Users can create a vote document if:
    //   - They are authenticated.
    //   - The 'userId' field in the document data matches their auth UID.
    //   - The 'featureId' field exists in the document data.
    //   - The document's ID ({voteId}) matches the pattern "data.userId + '_' + data.featureId".
    // This ensures a user can only create one vote document per feature for themselves.
    match /userVotes/{voteId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow create: if request.auth != null &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.featureId != null &&
                       voteId == request.resource.data.userId + '_' + request.resource.data.featureId;
      // No updates or deletes for votes to keep it simple and prevent tampering.
    }
  }
}
